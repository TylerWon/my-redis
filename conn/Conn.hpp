#include "../buffer/Buffer.hpp"
#include "../request/Request.hpp"
#include "../timers/IdleTimer.hpp"

/* Client connection to the server */
class Conn {
    public:
        int fd = -1;

        // application's intention, for the event loop
        bool want_read = false;
        bool want_write = false;
        bool want_close = false;

        Buffer incoming = Buffer();  // data to be parsed by the application
        Buffer outgoing = Buffer();  // responses generated by the application

        IdleTimer idle_timer; // if expiry time reached, connection has been idle for too long

        Conn(int fd, bool want_read, bool want_write, bool want_close) : fd(fd), want_read(want_read), want_write(want_write), want_close(want_close) {};
               
        /**
         * Handles when data is ready to be sent over the connection. 
         * 
         * Sends data in the outgoing buffer over the socket, removing it from the buffer afterwards. The connection's 
         * intention is also switched to "read" if there is no more data in the outgoing buffer.
         * 
         * If something goes wrong while sending the data, returns early. 
         */
        void handle_send();

        /**
         * Handles when data is ready to be received on the connection.
         * 
         * Receives data on the socket, saving it to the incoming buffer. If requests can be parsed from the incoming
         * buffer, exceutes the commands contained in the requests. Lastly, switches the connection's intention to 
         * "write" if there is data in the outgoing buffer to prevent the connection from always reading.
         * 
         * If something goes wrong while receiving the data, returns early.
         * 
         * @param kv_store      Reference to the kv store.
         * @param ttl_timers    Reference to the TTL timers for entries in the kv store.
         * @param thread_pool   Reference to the thread pool used for asynchronous work.
         */
        void handle_recv(HMap &kv_store, MinHeap &ttl_timers, ThreadPool &thread_pool);

        /**
         * Handles when the connection should be closed.
         * 
         * Removes the idle timer for the connection and the connection itself from the map of all active connections.
         * 
         * @param fd_to_conn    Reference to the map of all active connections, indexed by fd.
         * @param idle_timers   Reference to the idle timers for active connections.
         */
        void handle_close(std::vector<Conn *> &fd_to_conn, Queue &idle_timers);
    private:
        /**
         * Sends data over the connection, removing it from the outgoing buffer afterwards.
         * 
         * Sets the connection's intention to "close" if an error occurs.
         * 
         * @return  True if data is sent successfully.
         *          False if the socket isn't ready or an error occurs.
         */
        bool send_data();

        /**
         * Receives data over the connection, storing it in the incoming buffer.
         * 
         * Sets the connection's intention to "close" if the peer terminated the connection.
         * 
         * @return  True if data is received successfully.
         *          False if socket isn't ready, an error occurs, or the peer terminated the connection.
         */
        bool recv_data();

        /**
         * Tries to parse a request from the incoming buffer, removing it from the buffer afterwards.
         * 
         * If a request can be parsed from the buffer but it exceeds the size limit, sets the connection's 
         * intention to "close".
         * 
         * @return  Pointer to the Request on success.
         *          NULL if request cannot be parsed.
         */
        Request *parse_request();
};
