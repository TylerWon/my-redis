#pragma once

#include "../buffer/Buffer.hpp"
#include "../hashmap/HMap.hpp"
#include "../min-heap/MinHeap.hpp"
#include "../request/Request.hpp"
#include "../timers/IdleTimer.hpp"
#include "../thread-pool/ThreadPool.hpp"

/* Client connection to the server */
class Conn {
    public:
        int fd = -1;

        // application's intention, for the event loop
        bool want_read = false;
        bool want_write = false;
        bool want_close = false;

        Buffer incoming = Buffer();  // data to be parsed by the application
        Buffer outgoing = Buffer();  // responses generated by the application

        IdleTimer idle_timer; // if expiry time reached, connection has been idle for too long

        Conn(int fd, bool want_read, bool want_write, bool want_close) : fd(fd), want_read(want_read), want_write(want_write), want_close(want_close) {};
               
        /**
         * Handles when data is ready to be sent over the connection. 
         * 
         * Sends data in the outgoing buffer over the socket, removing it from the buffer afterwards. The connection's 
         * intention is also switched to "read" if there is no more data in the outgoing buffer.
         * 
         * If something goes wrong while sending the data, returns early. 
         */
        void handle_send();

        /**
         * Handles when data is ready to be received on the connection.
         * 
         * Receives data on the socket, saving it to the incoming buffer. While requests can be parsed from the incoming
         * buffer, exceutes the commands contained in the requests. Lastly, switches the connection's intention to 
         * "write" if there is data in the outgoing buffer to prevent the connection from always reading.
         * 
         * If something goes wrong while receiving the data, returns early.
         * 
         * @param kv_store      Reference to the kv store.
         * @param timers        Reference to the timer manager.
         * @param thread_pool   Reference to the thread pool used for asynchronous work.
         */
        void handle_recv(HMap &kv_store, TimerManager &timers, ThreadPool &thread_pool);

        /**
         * Handles when the connection should be closed.
         * 
         * Closes the socket, clears the idle timer for the connection, and the connection itself from the map of all 
         * active connections.
         * 
         * @param fd_to_conn    Reference to the map of all active connections, indexed by fd.
         * @param timers        Pointer to the timer manager.
         */
        void handle_close(std::vector<Conn *> &fd_to_conn, TimerManager *timers);
    private:
        /**
         * Sends data over the connection, removing it from the outgoing buffer afterwards.
         * 
         * Sets the connection's intention to "close" if an error occurs.
         * 
         * @param send  Function to use for sending data over the socket.
         * 
         * @return  True if data is sent successfully.
         *          False if the socket isn't ready or an error occurs.
         */
        bool send_data(ssize_t (*send)(int fd, const void *buf, size_t n, int flags));

        /**
         * Receives data over the connection, storing it in the incoming buffer.
         * 
         * Sets the connection's intention to "close" if an unexpected error occurred or the peer terminated the 
         * connection.
         * 
         * @param recv  Function to use for receiving data over the socket.
         * 
         * @return  True if data is received successfully.
         *          False if socket isn't ready, an error occurs, or the peer terminated the connection.
         */
        bool recv_data(ssize_t (*recv)(int fd, void *buf, size_t n, int flags));

        /**
         * Tries to parse a request from the incoming buffer, removing it from the buffer afterwards.
         * 
         * If the parsed request exceeds the size limit, the connection's intention is set to "close".
         * 
         * @return  Pointer to the Request on success.
         *          NULL if request cannot be parsed.
         */
        Request *parse_request();
    
    #ifdef TEST_MODE
    public:      
    #else
    private:
    #endif
        /**
         * Logic for handle_send(). 
         * 
         * Accepts a function for sending data over the socket. This allows the send to be mocked which improves 
         * testability.
         * 
         * @param send  Function to use for sending data over the socket.
         */
        void handle_send_fn(ssize_t (*send)(int fd, const void *buf, size_t n, int flags));

        /**
         * Logic for handle_recv(). 
         * 
         * In addition to the parameters for handle_recv(), accepts functions for sending and receiving data over the 
         * socket. This allows the receive to be mocked which improves testability.
         * 
         * @param kv_store      Reference to the kv store.
         * @param timers        Reference to the timer manager.
         * @param thread_pool   Reference to the thread pool used for asynchronous work.
         * @param recv          Function to use for receiving data over the socket.
         * @param send          Function to use for sending data over the socket.
         */
        void handle_recv_fn(HMap &kv_store, TimerManager &timers, ThreadPool &thread_pool, ssize_t (*recv)(int fd, void *buf, size_t n, int flags), ssize_t (*send)(int fd, const void *buf, size_t n, int flags));
};
